exit
c
cc
c
q
mid
c
n
mid*mid
mid
exit
mid_point
nums
mid
exit
include?(val, current.right)
current.right
val
current
n
@root.right.right.right.nil?
@root.right.right.right
@root.right.right
@root.right
@root
bst
current.value
current
n
current
current.right
current
c
n
current
n
current
n
exit
c
cc
c
n
nn
n
exit
current
n
current.value
n
current
current.right
current.left
current.value
curren.value
val
exit
current.value == val
n
exit
current.value == 10
val
current == val
current.class
current
q
mid
arr[mid]
n
mid
moid
arr[mid
arr
q
qy
q
exit
bst.root
bst.root.left.right
bst.root.left
bst.left
bst
exit
bst
exit
bst.left.right
bst.left.left
bst.left
bst
exit
bst.right.right.left
bst.right.right
bst.right
bst.right.left.left
bst.right.left
bst.right
bst.left.right.right
bst.left.right
bst.left
bst.left.left.left
bst.left.left
bst.left.let
bst.left
bst
bst.root.left
bst.left
exit
bst.root.left
bst.root
bst.left
bst
exit
bst.root
bst.root.left
bst.left
bst
exit
bst
exit
bst
exit
bst
bst.right
bst.left
exit
bst_node ? true : false
node
bst_node ? 
bst_node
node
exit
bst.class
bst
exit
bst.class
bst
exit
bst.class
bst
bst.root
bst
exit
bst.root.left.left
bst.root.left
bst.root
bst.value
bst.root.value
bst.root
bst
exit
bst.root.left.value
bst.root.left
bst.root
bst
exit
bst.root.left.right.right.right
bst.root.left.right.right
bst.root.left.right.left.right
bst.root.left.right.left
bst.root.left.right
bst.root.left.left
bst.root.left.value
bst.root.value
bst.root
arr
bst
exit
arr
exit
bst.root.value
exit
bst.root.value
bst.root
bst
exit
arr.sort!
arr
bst.root.value
bst.root
bst
c
value
c
exit
puts bst.root.left
puts bst.root
puts bst
c
exit
puts current
puts "hello"
"#{current}"
current
print current
puts current
p current
current.to_s
current.value
current
exit
bst
exit
bst.root.left.left.right.right
bst.root.left.left.right
bst.root.left.left.left
bst.root.left.left
bst.root.left
.left
bst.root.left.right
bst.root.left
bst.root
bst.left
bst
exit
bst.root.left.left.left
bst.root.left.left
bst.root.left
bst.root
bst.left
bst
exit
val <=> current.value
exit
current
val <=> current
val
exit
xit
var
v
v <=> current
